#include "general.h"
#include "symTable.h"

int lex();
int charClass, token, nextToken;

/* stmts
 * Parses strings in the language generated by the rule:
 *   <stmts> -> <stmt> 
 *            | <stmts> <stmt>
 */
int stmts()
{
   int var;
   var = stmt();
   return var;
}

/* stmt
 * Parses strings in the language generated by the rule:
 *   <stmt> -> <var> = <expr>
 *           | if <cond> then <stmts> fi
 *           | if <cond> then <stmts> else <stmts> fi
 *           | while <cond> do <stmts> done
 *           | print <var>
 *           | #comment
 *           | dump
 *           | quit
 */
int stmt()
{
   Symbol_ptr identifier;
   VALUE var;
   /*handles identifiers*/
   if (nextToken == IDENT && peek == '=')
   {
      table.insert(lexeme);
      identifier = table.lookup(lexeme);
      lex();
      /*assigns value to id*/
      if (nextToken == ASSIGN_OP)
      {
         lex();
         var.ivalue = expr();
         identifier->putval(var);
      }
      /* handles getting value of variable */
      else
      {
         var.ivalue = identifier->getval().ivalue;
      }
   }
   /* handles if */
   else if (nextToken == IF_STMT)
   {
      /* declare local variables */
      bool condition;
      int statement;
      int option;

      condition = cond();

      // cout << "nextToken: " << nextToken << endl;
      // cout << "lexeme:" << lexeme << endl;

      if (condition && nextToken == THEN_STMT)
      {
         lex();
         statement = stmts();
      }
      else if (condition == false)
      {
         lex();
         option = optelse();
         cout << "option: " << option << endl;
      }
      else
      {
         cout << "ERROR! INCORRECT IF FORMAT!" << endl;
      }
      //cout << condition << endl;
   }
   else if (nextToken == PRINT)
   {
      lex();
      identifier = table.lookup(lexeme);
      cout << "\t" << identifier->getid()
           << " = " << identifier->getval().ivalue << endl;
   }
   /* handles quit */
   else if (nextToken == QUIT)
   {
      cout << "bye!" << endl;
      exit(0);
   }
   /* handles dump */
   else if (nextToken == DUMP)
   {
      table.dump_table();
   }
   /* handles comments */
   else if (nextToken == COMMENT)
   {
      while (charClass != NEWLINE)
         getChar();
   }
   /* handles INT_LIT */
   else
   {
      var.ivalue = expr();
      // cout << "\t= " << var.ivalue << endl;
   }
   return var.ivalue;
}

/* cond
 * Parses strings in the language generated by the rule:
 *   <cond> -> <expr> <rel_op> <expr>
 */
bool cond()
{
   /* declare local variables */
   int expr1, expr2;

   lex();
   /* Parse the first term */
   expr1 = expr();
   while (nextToken == EQ_OP ||
          nextToken == NOTEQ_OP ||
          nextToken == LESSEQ_OP ||
          nextToken == GREATEQ_OP ||
          nextToken == GREAT_OP ||
          nextToken == LESS_OP)
   {
      if (nextToken == EQ_OP)
      {
         lex();
         expr2 = expr();
         if (expr1 == expr2)
            return true;
         else
            return false;
      }
      else if (nextToken == NOTEQ_OP)
      {
         lex();
         expr2 = expr();
         if (expr1 != expr2)
            return true;
         else
            return false;
      }
      else if (nextToken == LESSEQ_OP)
      {
         lex();
         expr2 = expr();
         if (expr1 <= expr2)
            return true;
         else
            return false;
      }
      else if (nextToken == LESS_OP)
      {
         lex();
         expr2 = expr();
         if (expr1 < expr2)
            return true;
         else
            return false;
      }
      else if (nextToken == GREATEQ_OP)
      {
         lex();
         expr2 = expr();
         if (expr1 >= expr2)
            return true;
         else
            return false;
      }
      else if (nextToken == GREAT_OP)
      {
         lex();
         expr2 = expr();
         if (expr1 > expr2)
            return true;
         else
            return false;
      }
   }
   return -1;
}

/* optelse
 * Parses strings in the language generated by the rule:
 *   <optional_else> -> else <stmts> fi
 *                    | fi
 */
int optelse()
{
   int statement;
   cout << "lexeme:" << lexeme << endl;
   if (nextToken == ELSE_STMT)
   {
      lex();
      statement = stmts();
      cout << "lexeme:" << lexeme << endl;
      if (nextToken == FI_STMT)
      {
         return statement;
      }
   }
   else if (nextToken == FI_STMT)
   {
      cout << "lexeme:" << lexeme << endl;
      return nextToken;
   }
   else
   {
      cout << "ERROR IN ELSE STATEMENT!" << endl;
   }
   return -1;
}

/* expr
   Parses strings in the language generated by the rule:
   <expr> -> <term> {(+ | -) <term>}
 */
int expr()
{
   /* declare local variables */
   int var, var2;

   /* Parse the first term */
   var = term();

   /* As long as the next token is + or -, get
      the next token and parse the next term */
   while (nextToken == ADD_OP || nextToken == SUB_OP)
   {
      if (nextToken == ADD_OP)
      {
         lex();
         var2 = term();
         var += var2;
      }
      else if (nextToken == SUB_OP)
      {
         lex();
         var2 = term();
         var -= var2;
      }
   }
   return var;

} /* End of function expr */

/* term
 *  Parses strings in the language generated by the rule:
 *  <term> -> <unary> {(* | / | %) <unary>)
 */
int term()
{
   int var, var2;
   /* Parse the first factor */
   var = unary();
   /* As long as the next token is *, /, or %, get the
      next token and parse the next factor */
   while (nextToken == MULT_OP || nextToken == DIV_OP || nextToken == MOD_OP)
   {
      if (nextToken == MULT_OP)
      {
         lex();
         var2 = unary();
         var *= var2;
      }
      else if (nextToken == DIV_OP)
      {
         lex();
         var2 = unary();
         var /= var2;
      }
      else if (nextToken == MOD_OP)
      {
         lex();
         var2 = unary();
         var %= var2;
      }
   }
   return var;
} /* End of function term */

/* unary
 * Parses strings in the language generated by the rule:
 *   <unary> -> - <expo>
 */
int unary()
{
   int var;
   var = expo();

   while (nextToken == SUB_OP && token != INT_LIT && token != IDENT)
   {
      lex();
      var = expo();
      var = -var;
   }

   return var;
}

/* expo
 * Parses strings in the language generated by the rule:
 *   <expo> -> <factor> ^ <factor>
 */
int expo()
{
   int var, var2;

   var = factor();

   while (nextToken == EXPO_OP)
   {
      if (nextToken == EXPO_OP)
      {
         lex();
         var2 = factor();
         var = pow(var, var2);
      }
   }

   return var;
}

/* factor
 * Parses strings in the language generated by the rule:
 *   <factor> -> id | int_constant | ( <expr> )
 */
int factor()
{
   VALUE var;
   Symbol_ptr identifier;
   /* Determine which RHS */
   if (nextToken == INT_LIT)
   {
      var.ivalue = atoi(lexeme);
      /* Get the next token */
      lex();
   }
   else if (nextToken == IDENT)
   {
      identifier = table.lookup(lexeme);
      var.ivalue = identifier->getval().ivalue;
      lex();
   }

   /* If the RHS is ( <expr> ), call lex to pass over the left 
      parenthesis, call expr and check for the right parenthesis */
   else if (nextToken == LEFT_PAREN)
   {
      lex();
      var.ivalue = expr();
      if (nextToken == RIGHT_PAREN)
         lex();
      else
         error("Right without left paren");
   }
   else if (nextToken == SUB_OP)
   {
      return var.ivalue;
   }
   else
   {
      /* It was not an id, an integer literal, or a left
       parenthesis */
      error("expected an id, integer, or a left paren");
   } /* End of else */
   return var.ivalue;
} /* End of function factor */

void error(const char *message)
{
   printf("Error: %s\n", message);
}